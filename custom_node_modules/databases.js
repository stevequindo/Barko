/***************** CONSTANTS AND NODE REQS*****************/
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

// Connection URL
const url = 'mongodb+srv://nchong128:apple123@cluster0-7jrih.mongodb.net';
const databaseName = "balikbayanDB";
mongoose.connect(`${url}/${databaseName}`, {useNewUrlParser: true});

// Flags
let flags = require('country-flags-svg');
let _ = require('lodash');

/***************** SCHEMAS AND MODELS *****************/
// Create sender schema and model
const senderSchema = new mongoose.Schema({
	_id: Schema.Types.ObjectId,
	lastName: {
		type: String
	},
	firstName: {
		type: String
	},
	middleName: String,
	address: String,
	transactionHolder: {
		type: Schema.Types.ObjectId,
		ref: 'Transaction'
	}
});

const Sender = mongoose.model("Sender", senderSchema);

// Create receiver schema and model
const receiverSchema = new mongoose.Schema({
	_id: Schema.Types.ObjectId,
	lastName: {
		type: String
	},
	firstName: {
		type: String
	},
	middleName: String,
	address: String,
	transactionHolder: {
		type: Schema.Types.ObjectId,
		ref: 'Transaction'
	}
});

const Receiver = mongoose.model("Receiver", receiverSchema);

// Create transaction schema and model
const transactionSchema = new mongoose.Schema({
	_id: Schema.Types.ObjectId,
	count: Number, 
	batchNo: Number,
	trackingNumber: {
		type: String
	},
	area: {
		type: String,
		default: ""
	},
	status: {
		type: String,
		default: "NZ Port"
	},
	comment: {
		type: String,
		default: ""
	},
	sender_link: {
		type: Schema.Types.ObjectId,
		ref: 'Sender'
	},
	receiver_link: {
		type: Schema.Types.ObjectId,
		ref: 'Receiver'
	},
	grouped_by: {
		type: Schema.Types.ObjectId,
		ref: 'Container'
	}
});

const Transaction = mongoose.model("Transaction", transactionSchema);

// Create container schema and model
const containerSchema = new mongoose.Schema({
	transactions: [{
		type: Schema.Types.ObjectId,
		ref: 'Transaction'
	}],
	dateAdded: Date,
	dateLastAccessed: Date,
	containerCompany: String,
	departureCountry: String,
	arrivalCountry: String,
	shipmentDeparture: Date,
	shipmentArrival: Date,
	shipName: String,
});

const Container = mongoose.model("Container", containerSchema);

/***************** FUNCTIONS *****************/
exports.parseJsonWorkbook = function(jsonWorkbook) {
	/*
	This function processes a spreadsheet's contents and uploads it into the database

	Error Handling:
		- Skips over empty sheets
		- TODO: Adjust error handling for when sender/receiver has no last name or first name
	Params:
		jsonWorkbook: Object containing sheet info to be processed
	Returns:
		Object containing statistics about the process
	*/

	// summary object for statistics
   let summary = {
		containersAdded: 0,
		sendersAdded: 0,
		receiversAdded: 0,
		transactionsAdded:0,
	   	emptySheets: 0,
   };

   // Iterate over every sheet in the excel file
   for (let sheet in jsonWorkbook) {
	   // Obtain array of spreadsheet rows
	   let arrayOfRows = jsonWorkbook[sheet];

	   // Update statistics
	   if (arrayOfRows.length == 0) {
		   console.log(`Sheet ${sheet} is empty. Skipping...`);
		   summary.emptySheets ++;
		   continue;
	   } else {
		   console.log(`Sheet ${sheet} is being processed...`);
		   summary.containersAdded ++;
	   }

	   // Obtain header row (row containing the column names)
	   let headerRow = [];
	   for (let columnName in arrayOfRows[0]) {
		   headerRow.push(columnName);
	   }
	   summary.headerRow = headerRow;

	   // Iterate over every row
	   let transactionArray = [];

	   // Create container
	   let container = new Container({
		   transactions: [],
		   dateAdded: new Date(),
		   dateLastAccessed: new Date(),
		   departureCountry: "new zealand",
		   containerCompany: "FastTraxx",
	   });

	   // Iterate over every row (besides the header row)
	   for (let i = 0; i < arrayOfRows.length; i++) {
		   let row = arrayOfRows[i];

		   // Create sender object
		   let sender = new Sender({
			   _id: new mongoose.Types.ObjectId(),
			   lastName: row["Last Name"],
			   firstName: row["First Name"],
			   middleName: row["Middle Name"],
			   address: row["Address"]
		   });

		   // Create receiver object
		   let receiver = new Receiver({
			   _id: new mongoose.Types.ObjectId(),
			   lastName: row["Last Name_1"],
			   firstName: row["First Name_1"],
			   middleName: row["Middle Name_1"],
			   address: row["Address_1"],
		   });

		   // Create transaction object
		   let transaction = new Transaction({
			   _id: new mongoose.Types.ObjectId(),
			   count: row["Count"],
			   batchNo: row["Batch No."],
			   trackingNumber: row["Tracking No."],
			   area: row["Area"],
			   sender_link: sender._id,g
			   receiver_link: receiver._id
		   });

		   // Add transaction to transactionArray
		   container.transactions.push(transaction);

		   // Save models to DB
		   sender.save();
		   receiver.save();
		   transaction.save();

		   // Increment counts
		   summary.sendersAdded++;
		   summary.transactionsAdded++;
		   summary.receiversAdded++;
	   }
		// Save container
		container.save().catch((e) => {throw Error(e)});

	   console.log(`Finished processing for ${sheet}`);
	}
	return summary;
};

exports.findStatus = function(trackingNum) {
	/*
	This function finds the status of an existing transaction based on the tracking number

	Params:
		trackingNumber: String containing tracking number to find status
	Returns:
		Promise: with the status in the resolution. Or else it rejects with the message
	*/

	return new Promise(function (resolve, reject) {
		Transaction.find({trackingNumber: trackingNum}, 'status', (err, docs) => {
			if (docs.length > 0) {
				let status = docs[0].status;
				resolve(status);
			} else {
				reject("No results returned");
			}
		});
	});
};

exports.findSender = function(trackingNum) {
	/*
	This function finds the sender of an existing transaction based on the tracking number

	Params:
		trackingNumber: String containing tracking number to find status
	Returns:
		Promise: with the status in the resolution. Or else it rejects with the message
	*/
	return new Promise(function (resolve, reject) {

		let sender_link;
		Transaction.find({trackingNumber: trackingNum}, 'sender_link', (err, docs) => {
			if (docs.length > 0) {
				sender_link = docs[0].sender_link;

				Sender.find({_id: sender_link}, 'firstName lastName', (err, docs) => {
					if (docs.length > 0) {
						let firstName = docs[0].firstName;
						let lastName = docs[0].lastName;
						let Name = firstName + " " + lastName;
						resolve(Name);

					} else {
						reject("No results returned");
					}
				});
			} else {
				reject("No results returned");
			}
		});
	});
};

exports.findReceiver = function(trackingNum) {
	/*
	This function finds the receiver of an existing transaction based on the tracking number

	Params:
		trackingNumber: String containing tracking number to find status
	Returns:
		Promise: with the status in the resolution. Or else it rejects with the message
	*/
	return new Promise(function (resolve, reject) {

		let receiver_link;
		Transaction.find({trackingNumber: trackingNum}, 'receiver_link', (err, docs) => {
			if (docs.length > 0) {
				receiver_link = docs[0].receiver_link;

				Receiver.find({_id: receiver_link}, 'firstName lastName', (err, docs) => {
					if (docs.length > 0) {
						let firstName = docs[0].firstName;
						let lastName = docs[0].lastName;
						let Name = firstName + " " + lastName;
						resolve(Name);

					} else {
						reject("No results returned");
					}
				});
			} else {
				reject("No results returned");
			}
		});
	});
};

// NOTE: Arbitrary function for the trial
getCountriesAux = function() {
	let nzCountry = {
		countryName: 'New Zealand',
		freightCount: 50040
	};

	nzCountry.flagUrl = flags.findFlagUrlByCountryName(nzCountry.countryName);

	let totalArray = [nzCountry];
	return totalArray;
};

// NOTE: Arbitrary function for the trial
exports.getCountries = function() {
	//prolly gonna be ISO code in the future
	return getCountriesAux();
};

exports.getContainers = async function(country) {
	/*
	This function retrieves all of the containers for a given country.

	Params: None
	Return: Promise containing the transactions in the resolution
	 */
	return Container.find({departureCountry: country}, 'transactions dateAdded departureCountry containerCompany');
};

exports.getTransactions = async function(id, country) {
	/*
	This function retrieves all of the transactions for a given ID and country (usually given by the link).
	Also updates the container's last accessed date.

	Params: None
	Return: Promise containing the transactions in the resolution
 	*/

	// Update the container's dateLastAccessed
	await Container.updateOne({_id: id, departureCountry: country}, {dateLastAccessed: new Date()});

	// Now return the transactions for the given container
	return Container.findOne({_id: id, departureCountry: country}, 'transactions')
		.populate({
			path: 'transactions',
			populate: {path: 'sender_link receiver_link'}
		});
};

exports.getLatestTransactionInfo = function() {
	/*
	This function returns the _id and country of the most recent manifest. The most recent manifest is determined by
	either the last accessed or the last created (last created having a higher priority).

	Return: Object containing _id and departureCountry
	Params: None
	 */

	// // Check for all containers, the container with the latest Date for either the dateLastAccessed or dateAdded
	return Container.findOne({}, '_id departureCountry', {sort: {dateLastAccessed : -1}});
};

exports.updateEntries = async function(obj) {
	/*
	This function updates the status and comments of specified rows

	Params:
		- obj: Object with key as the transaction's _id and value as the object containing status : <newStatus>
		and comment: <newComment>
	Returns:
		- Object containing the updated transactions
	 */

	let resultJSON = {
		data: []
	};

	// Iterate over every _id value
	for (let i in obj) {
		let id = i;
		let newStatus = obj[i].status;
		let newComment = obj[i].comment;

		let resultsObj = {
			_id: id,
			status: newStatus,
			comment: newComment
		};
		resultJSON.data.push(resultsObj);

		// Update the Transaction with the new status and comment
		await Transaction.updateOne({_id: id}, {status: newStatus, comment: newComment}, (err, res) => {
			if (err) {
				console.error(err);
				return err;
			}
		});
	}

	return resultJSON;
};