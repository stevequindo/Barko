/***************** CONSTANTS AND NODE REQS*****************/
const mongoose = require('mongoose');

// Connection URL
const url = 'mongodb+srv://nchong128:apple123@cluster0-7jrih.mongodb.net';
const databaseName = "balikbayanDB";
mongoose.connect(`${url}/${databaseName}`, {
	useNewUrlParser: true,
	useFindAndModify: false
});

// Flags
let flags = require('country-flags-svg');
let _ = require('lodash');

// Import models
const schema = require("./models/dbSchema");
const Container = schema.Container;
const ContainerLine = schema.ContainerLine;
const User = require('./models/users');

/***************** FUNCTIONS *****************/
exports.parseJsonWorkbook = async function(jsonWorkbook, userData) {
	/*
	This function processes a spreadsheet's contents and uploads it into the database

	Error Handling:
		- Skips over empty sheets
		- TODO: Adjust error handling for when sender/receiver has no last name or first name
	Params:
		jsonWorkbook: Object containing sheet info to be processed
	Returns:
		Object containing statistics about the process
	*/

	// summary object for statistics
   let summary = {
		containersAdded: 0,
		sendersAdded: 0,
		receiversAdded: 0,
		transactionsAdded:0,
	   	emptySheets: 0,
   };

   // Iterate over every sheet in the excel file
   for (let sheet in jsonWorkbook) {
	   // Obtain array of spreadsheet rows
	   let arrayOfRows = jsonWorkbook[sheet];

	   // Update statistics
	   if (arrayOfRows.length === 0) {
		   console.log(`Sheet ${sheet} is empty. Skipping...`);
		   summary.emptySheets ++;
		   continue;
	   } else {
		   console.log(`Sheet ${sheet} is being processed...`);
		   summary.containersAdded ++;
	   }

	   // Iterate over every row
	   let transactionArray = [];

	   // Create container
	   let container = new Container({
		   _id: new mongoose.Types.ObjectId(),
		   dateAdded: new Date(),
		   dateLastAccessed: new Date(),
		   containerLine: []
	   });

	   // Add access based on uploader's role
	   if (userData.local.role === "overseas") {
	       container.overseasAccess = userData._id;

	   } else if (userData.local.role === "staff") { //TODO: Change to "local" when doing whole refactor
		   container.localAccess = userData._id;
	   }

	   // Iterate over every row (besides the header row)
	   for (let i = 0; i < arrayOfRows.length; i++) {
		   let row = arrayOfRows[i];

		   // Get departure and arrival country based on first row
		   if (i === 0) {
		       container.departureCountry = row["Country"];
		       container.targetCountry = row["Country_1"];
		   }

		   // Create ContainerLine object
		   let containerLine = new ContainerLine({
			   _id: new mongoose.Types.ObjectId(),
			   count: row["Count"],
			   batchNo: row["Batch No."],
			   trackingNo: row["Tracking No."],
			   area: row["Area"],
			   status: {
			   	   stage: "At Departing Port"
			   },
			   sender: {
				   firstName: row["First Name"],
				   middleName: row["Middle Name"],
				   lastName: row["Last Name"],
				   address: row["Address"],
				   suburb: row["Suburb"],
				   city: row["City"],
				   postCode: row["Postal Code"],
				   region: row["Region"],
				   country: row["Country"],
				   dob: row["DOB (mm/dd/yyyy)"],
				   mobileNo: row["Mobile/Tel Nos."],
				   email: row['Email Address']
			   },
			   receiver: {
				   firstName: row["First Name_1"],
				   middleName: row["Middle Name_1"],
				   lastName: row["Last Name_1"],
				   address: row["Address_1"],
				   city: row["City_1"],
				   province: row["Province"],
				   country: row["Country_1"],
				   contactNo: row["Contact Number/s"],
				   email: row['Email Address_1']
			   }
		   });

		   // Add ContainerLine instance to Container instance
		   container.containerLine.push(containerLine);

		   // Increment counts
		   summary.sendersAdded++; summary.transactionsAdded++; summary.receiversAdded++;
	   }

	   // Save user access
	   await User.findOneAndUpdate({_id: userData._id}, {$push: {"local.access": container._id}}, {"upsert": true});

	   // Save container
	   container.save();

	   console.log(`Finished processing for ${sheet}`);
	}

   return summary;
};

exports.findStatusInfo = function(trackingNum, Surname) {
	/**
	 * This function finds the status information given a tracking number and the SENDER's surname
	 *
	 * Params:
	 * 	- trackingNum (String) representing the tracking number
	 * 	- Surname (String) representing the surname of the sender
	 * Returns:
	 *  - Promise containing an object of the specific container line
	 */
	return new Promise((resolve, reject) => {
		let lastName = '^'+Surname+'$';

		Container
			.findOne({ 
				'containerLine': { 
					$elemMatch: {
						'trackingNo':trackingNum,
						'sender.lastName': {
							'$regex': lastName, $options:'i'
						}
					}
				}}, 
				{
					'containerLine': {
						$elemMatch: {
							'trackingNo':trackingNum,
							'sender.lastName': {
								'$regex': lastName,$options:'i'
							}
						}
					}
				})
			.populate('containerLine[0].sender containerLine[0].receiver containerLine[0].status')
			.exec((err, docs) => {
				if (docs !== null && docs !== undefined)
					resolve(docs.containerLine[0]);
				else
					reject("No results returned");
			});
	});
};

exports.getCountries = function(userData) {
	// Get all the countries associated with the given user and aggregate into different countries
	return new Promise((resolve, reject) => {
		if (userData.local.role === "staff") {
			Container.aggregate()
				.match({localAccess: userData._id})
				.project("departureCountry")
				.group({_id: "$departureCountry",  numOfContainers: {$sum : 1}})
				.exec((err, doc) => {
					if (err) reject(err);
					doc.forEach((item) => {
						item.flagUrl = flags.findFlagUrlByCountryName(item._id);
					});
					resolve(doc);
				});
		} else if (userData.local.role === "overseas") {
			Container.aggregate()
				.match({localAccess: userData._id})
				.project("targetCountry")
				.group({_id: "$targetCountry",  numOfContainers: {$sum : 1}})
				.exec((err, doc) => {
					if (err) reject(err);
					doc.forEach((item) => {
						item.flagUrl = flags.findFlagUrlByCountryName(item._id);
					});
					resolve(doc);
				});
		}
	});
};

exports.getContainers = async (country, userData) => {
	/*
	This function retrieves all of the containers for a given country.

	Params: None
	Return: Promise containing the transactions in the resolution
	 */
	if (userData.local.role === "staff") {
		let docs = await Container.aggregate()
			.match({
				departureCountry: {$regex: new RegExp('^' + country, 'i')},
				localAccess: userData._id
			})
			.project({
				dateAdded: 1,
				overseasAccess: 1
			});

		for (let i  = 0; i < docs.length; i ++) {
			if (docs[i].hasOwnProperty("overseasAccess")) {
				let user = await User.findOne({_id: docs[i].overseasAccess}, '', {});
				docs[i].name = user.local.email;
			} else {
				docs[i].name = "Unknown";
			}
		}
		return docs;
	}
};

exports.getContainersByUser = async (userData) => {
	if (userData.local.role === "overseas") {
		let docs = await Container.aggregate()
			.match({
				overseasAccess: userData._id
			})
			.project({
				dateAdded: 1,
				localAccess: 1
			});

		for (let i  = 0; i < docs.length; i ++) {
			if (docs[i].hasOwnProperty("localAccess")) {
				let user = await User.findOne({_id: docs[i].localAccess}, '', {});
				docs[i].name = user.local.email;
			} else {
				docs[i].name = "Unknown";
			}
		}
		return docs;
	}
};

exports.getContainerSettings = async function(containerId, userData) {
	return new Promise((resolve, reject) => {
		if (userData.local.role === "staff") {
			// Return settings for given container
			Container
				.findOne({_id: containerId, localAccess: userData._id})
				.populate('localAccess overseasAccess')
				.exec((err, docs) => {
					if (err) throw err;
					resolve(docs);
				});
		} else if (userData.local.role === "overseas") {
			// Return settings for given container
			Container
				.findOne({_id: containerId, overseasAccess: userData._id})
				.populate('localAccess overseasAccess')
				.exec((err, docs) => {
					if (err) throw err;
					resolve(docs);
				});
		}
	});
};

exports.updateContainerSettings = function(containerId, data, userData) {
	return new Promise((resolve, reject) => {
		if (userData.local.role === "staff") {
			// Search users to see if an suitable account matches
			User.findOne({"local.email" : data.overseasAccountEmail, "local.role": "overseas"}, (err,docs) => {
				if (err) throw err;

				// Now set the company to be the overseas account
				if (docs !== null) {
					Container.findOneAndUpdate({_id: containerId}, {overseasAccess: docs._id}, (err, docs) => {
						if (err) throw err;
						resolve(docs);
					})
				} else {
					reject("No account found.");
				}
			});
		} else if (userData.local.role === "overseas") {

		}
	});
};

exports.getContainerLines = async function(containerId, userData) {
	/*
	This function retrieves all of the transactions for a given container ID(usually given by the link).
	Also updates the container's last accessed date.

	Params:
	Return: Promise containing the transactions in the resolution
 	*/
	Container.updateOne({_id: containerId});

	if (userData.local.role === "staff") {
		// Now return the container lines for the given container
		return Container.findOneAndUpdate(
			{_id: containerId, localAccess: userData._id},
			{dateLastAccessed: new Date()},
			{fields : "containerLine"});
	} else if (userData.local.role === "overseas") {
		// Now return the container lines for the given container
		return Container.findOneAndUpdate(
			{_id: containerId, overseasAccess: userData._id},
			{dateLastAccessed: new Date()},
			{fields : "containerLine"});
	}
};

exports.getLatestTransactionInfo = function(userData) {
	/*
	// TODO: NEED TO SET QUERY TO INCLUDE ONLY THE USER'S ID
	This function returns the _id and country of the most recent manifest. The most recent manifest is determined by
	either the last accessed or the last created (last created having a higher priority).

	Return: Object containing _id and departureCountry
	Params: None
	 */

	if (userData.local.role === "staff") {
		return Container.findOne({localAccess: userData._id}, '_id', {sort: {dateLastAccessed : -1}});
	} else if (userData.local.role === "overseas") {
		return Container.findOne({overseasAccess: userData._id}, '_id', {sort: {dateLastAccessed : -1}});
	}
};

exports.updateEntries = async function(obj, userData, containerId) {
	/*
	This function updates the status and comments of specified rows

	Params:
		- obj: Object with key as the transaction's _id and value as the info to be updated
	Returns:
		- Object containing the updated transactions
	 */

	let resultJSON = {
		data: []
	};

	if (userData.local.role === "staff") {
		let container = await Container.findOne({"_id" : containerId});

		// Iterate over every _id value
		for (const id in obj) {
			let resultsObj = {
				_id: id,
				comment: obj[id].comment,
				status : {
					stage: obj[id].status.stage,
					estPortArrivalDate: obj[id].status.estPortArrivalDate,
					actPortArrivalDate: obj[id].status.actPortArrivalDate,
					estDeliveryDate: obj[id].status.estDeliveryDate,
					actDeliveryDate: obj[id].status.actDeliveryDate,
					receivedBy: obj[id].status.receivedBy
				}
			};

			resultJSON.data.push(resultsObj);

			// Update the Transaction with the new info
			await Container.findOneAndUpdate({ "_id": containerId, "containerLine._id": id },
				{
					"$set": {
						"containerLine.$.comment": resultsObj.comment,
						"containerLine.$.status.stage": resultsObj.status.stage,
						"containerLine.$.status.estPortArrivalDate": resultsObj.status.estPortArrivalDate,
						"containerLine.$.status.actPortArrivalDate": resultsObj.status.actPortArrivalDate,
						"containerLine.$.status.estDeliveryDate": resultsObj.status.estDeliveryDate,
						"containerLine.$.status.actDeliveryDate": resultsObj.status.actDeliveryDate,
						"containerLine.$.status.receivedBy": resultsObj.status.receivedBy,
					}
			});
		}
		return resultJSON;
	} else if (userData.local.role === "overseas") {
		let container = await Container.findOne({"_id" : containerId});

		// Iterate over every _id value
		for (const id in obj) {
			let resultsObj = {
				_id: id,
				batchNo: obj[id].batchNo,
				trackingNo: obj[id].trackingNo,
				count: obj[id].count,
				area: obj[id].area,
				sender: {
					firstName: obj[id].sender.firstName,
					lastName: obj[id].sender.lastName,
				},
				receiver: {
					firstName: obj[id].receiver.firstName,
					lastName: obj[id].receiver.lastName,
					address: obj[id].receiver.address
				},
			};

			resultJSON.data.push(resultsObj);

			// Update the Transaction with the new info
			await Container.findOneAndUpdate({ "_id": containerId, "containerLine._id": id },
				{
					"$set": {
						"containerLine.$.batchNo": resultsObj.batchNo,
						"containerLine.$.trackingNo": resultsObj.trackingNo,
						"containerLine.$.count": resultsObj.count,
						"containerLine.$.area": resultsObj.area,
						"containerLine.$.sender.firstName": resultsObj.sender.firstName,
						"containerLine.$.sender.lastName": resultsObj.sender.lastName,
						"containerLine.$.receiver.firstName": resultsObj.receiver.firstName,
						"containerLine.$.receiver.lastName": resultsObj.receiver.lastName,
						"containerLine.$.receiver.address": resultsObj.receiver.address,
					}
				});
		}
		return resultJSON;
	}
};